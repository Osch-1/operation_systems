Signals:
- буква a-zA-Zа-яА-Я {letter}
- цифра 0 1 2 3 4 5 6 7 8 9 {digit}
- разделитель { } [ ] ( ) . , : ; <space> \r \n {delimiter}
- оператор + - * / = ? & | ^ % ! ~ <, > {operator}
- начало/конец простой строки " {double_quote}
- начало/конец символа ' {quote}
- / - начало комментария
- другие

Acitons:
-store_symbol
-store_lexem
-throw

q0{empty_buffer}
  letter -> q3{identifier}/store_symbol
  digit -> q4{number}/store_symbol
  delimiter -> q5{delimiter}/store_symbol
  operator -> q6{operator}/store_symbol
  double_quote -> q2{string_literal}/store_symbol
  quote -> q1{character}/store_symbol
  / -> q6{operator}/store_symbol
  \ -> q7{comment}/store_symbol
  other -> q0{empty buffer}/store_lexem

q1{character}
  letter -> validate_state() if (valid) -> q1{character} else throw exception
  digit -> validate_state() if (valid) -> q1{character} else throw exception
  delimeter -> validate_state() if (valid) -> q1{character} else throw exception
  operator -> validate_state() if (valid) -> q1{character} else throw exception
  double_quote -> validate_state() if (valid) -> q1{character} else throw exception
  quote -> validate_state() if (valid) -> q1{character} else throw exception
  / -> validate_state() if (valid) -> q1{character} else throw exception
  \ -> validate_state() if (valid) -> q1{character} else throw exception
  other -> validate_state() if (valid) -> q1{character} else throw exception  
  
q2{string_literal}
  letter -> validate_state() if (valid) -> q2{string_literal} else throw exception
  digit -> validate_state() if (valid) -> q2{string_literal} else throw exception
  delimeter -> validate_state() if (valid) -> q2{string_literal} else throw exception
  operator -> validate_state() if (valid) -> q2{string_literal} else throw exception
  double_quote -> q2{string_leteral} + store_lexem + store_new_symbol
  quote -> validate_state() if (valid) -> q2{string_literal} else throw exception
  / -> validate_state() if (valid) -> q2{string_literal} else throw exception
  \ -> validate_state() if (valid) -> q2{string_literal} else throw exception
  other -> validate_state() if (valid) -> q2{string_literal} else throw exception
 
q3{identifier}
  letter -> validate_state() if (valid) -> q3{identifier} else throw exception
  digit -> validate_state() if (valid) -> q3{identifier} else throw exception
  delimeter -> validate_state() if (valid) -> q0{empty_buffer} + store_lexem + store_new_symbol else throw exception
  operator -> validate_state() if (valid) -> q0{empty_buffer} + store_lexem + store_new_symbol else throw exception
  double_quote -> validate_state() if (valid) -> q0{empty_buffer} + store_lexem + store_new_symbol else throw exception
  quote -> validate_state() if (valid) -> q0{empty_buffer} + store_lexem + store_new_symbol else throw exception
  / -> validate_state() if (valid) -> q0{empty_buffer} + store_lexem + store_new_symbol else throw exception
  \ -> validate_state() if (valid) -> q0{empty_buffer} + store_lexem + store_new_symbol else throw exception
  other -> validate_state() if (valid) -> q0{empty_buffer} + store_lexem + store_new_symbol else throw exception  

q4{number}
  letter -> validate_state() if (valid) -> q3{identifier} else throw exception
  digit -> validate_state() if (valid) -> q3{identifier} else throw exception
  delimeter -> validate_state() if (valid) -> q0{empty_buffer} + store_lexem + store_new_symbol else throw exception
  operator -> validate_state() if (valid) -> q0{empty_buffer} + store_lexem + store_new_symbol else throw exception
  double_quote -> validate_state() if (valid) -> q0{empty_buffer} + store_lexem + store_new_symbol else throw exception
  quote -> validate_state() if (valid) -> q0{empty_buffer} + store_lexem + store_new_symbol else throw exception
  / -> validate_state() if (valid) -> q0{empty_buffer} + store_lexem + store_new_symbol else throw exception
  \ -> validate_state() if (valid) -> q0{empty_buffer} + store_lexem + store_new_symbol else throw exception
  other -> validate_state() if (valid) -> q0{empty_buffer} + store_lexem + store_new_symbol else throw exception  
  
q5{delimiter}
  delimeter_part{it will be defined inside the state} -> q5{delimeter}
  else -> go to state by symbol + store_lexem (delimeter)
  
q6{operator}
  operator_part{it will be defined inside the state} -> q5{delimeter}
  else -> go to state by symbol + store_lexem (delimeter)
  
q7{comment}
  eoln -> q0{empty_buffer}
  eof -> throw
  else -> q7{comment}  
  
qe{error}
  throw error, maybe i won't add this state

Не поддерживается:
-raw string - @".."
-interpolation $"{}"
-generics
-char_literal inside string

Токены:
-Число десятичное со знаком 

-Идентификатор (может быть зарезервированным словом)

-Оператор

- состаной оператор ?? :: ++ -- && || -> == != <= >= += -= *= /= %= &= |= ^= << <<= => >> >>=

-Комментарий

-Разделитель

-Строка


Описание состояний автомата лексического анализатора:

q0 {empty} - означает, что мы только открыли файл/до этого встретили разделитель, в этому состоянии buffer не содержит символов
q1 {operator_or_comment} - означает, что buffer="/", здесь нужно считать символ и передать управление в следующее состояние в зависимости от символа
   Если встретили char in ['/', '*'], то:
    1. Добавляем char в buffer
	2. Передаем управление q_comment
   Иначе нужно:
    1. Выписать информацию, что нашли operator(/)
    2. Почистить buffer
    3. Сохранить новый символ в буффер
    4. Передать управление следующему состоянию
q_comment:
    1.GetChar()
	  Если // в начале и / на конце, и char == '/', то закончить выписать токен и передать управление q0
	  Если /* в начале и * на конце, и char == '/', то закончить выписать токен и передать управление q0
      Иначе ничего не делать
	  
	  
	  
