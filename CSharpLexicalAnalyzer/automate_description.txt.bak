Signals:
- буква a-zA-Zа-яА-Я {letter}
- цифра 0 1 2 3 4 5 6 7 8 9 {digit}
- разделитель { } [ ] ( ) . , : ; <space> \r \n {delimiter}
- оператор + - * / = ? & | ^ % ! ~ <, > {operator}
- начало/конец простой строки " {double_quote}
- начало/конец символа ' {quote}
- / - начало комментария
- другие

Acitons:
-store_symbol
-store_lexem
-throw

q0{empty buffer}
  letter -> q3{identifier}/store_symbol
  digit -> q4{number}/store_symbol
  delimiter -> q5{delimiter}/store_symbol
  operator -> q6{operator}/store_symbol
  double_quote -> q2{string_literal}/store_symbol
  quote -> q1{character}/store_symbol
  / -> q7{operator|comment}
  other -> q0{empty buffer}/store_lexem

q1{character}


q2{string_literal}
q3{identifier}
q4{number}
q5{delimiter}
q6{operator}
q7{operator|comment}
qe{error}

Токены:
-Число десятичное со знаком 

-Идентификатор (может быть зарезервированным словом)

-Оператор

- состаной оператор ?? :: ++ -- && || -> == != <= >= += -= *= /= %= &= |= ^= << <<= => >> >>=

-Комментарий

-Разделитель

-Строка


Описание состояний автомата лексического анализатора:

q0 {empty} - означает, что мы только открыли файл/до этого встретили разделитель, в этому состоянии buffer не содержит символов
q1 {operator_or_comment} - означает, что buffer="/", здесь нужно считать символ и передать управление в следующее состояние в зависимости от символа
   Если встретили char in ['/', '*'], то:
    1. Добавляем char в buffer
	2. Передаем управление q_comment
   Иначе нужно:
    1. Выписать информацию, что нашли operator(/)
    2. Почистить buffer
    3. Сохранить новый символ в буффер
    4. Передать управление следующему состоянию
q_comment:
    1.GetChar()
	  Если // в начале и / на конце, и char == '/', то закончить выписать токен и передать управление q0
	  Если /* в начале и * на конце, и char == '/', то закончить выписать токен и передать управление q0
      Иначе ничего не делать
	  
	  
	  
